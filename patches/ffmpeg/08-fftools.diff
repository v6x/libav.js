Index: ffmpeg-8.0/fftools/ffmpeg.c
===================================================================
--- ffmpeg-8.0.orig/fftools/ffmpeg.c
+++ ffmpeg-8.0/fftools/ffmpeg.c
@@ -320,22 +320,29 @@ static void ffmpeg_cleanup(int ret)
     for (int i = 0; i < nb_filtergraphs; i++)
         fg_free(&filtergraphs[i]);
     av_freep(&filtergraphs);
+    nb_filtergraphs = 0;
 
     for (int i = 0; i < nb_output_files; i++)
         of_free(&output_files[i]);
+    av_freep(&output_files);
+    nb_output_files = 0;
 
     for (int i = 0; i < nb_input_files; i++)
         ifile_close(&input_files[i]);
+    av_freep(&input_files);
+    nb_input_files = 0;
 
     for (int i = 0; i < nb_decoders; i++)
         dec_free(&decoders[i]);
     av_freep(&decoders);
+    nb_decoders = 0;
 
     if (vstats_file) {
         if (fclose(vstats_file))
             av_log(NULL, AV_LOG_ERROR,
                    "Error closing vstats file, loss of information possible: %s\n",
                    av_err2str(AVERROR(errno)));
+        vstats_file = NULL;
     }
     av_freep(&vstats_filename);
     of_enc_stats_close();
@@ -960,7 +967,12 @@ static int64_t getmaxrss(void)
 #endif
 }
 
+#ifdef __EMSCRIPTEN__
+int ffmpeg_main(int argc, char **argv);
+int ffmpeg_main(int argc, char **argv)
+#else
 int main(int argc, char **argv)
+#endif
 {
     Scheduler *sch = NULL;
 
@@ -1026,11 +1038,15 @@ finish:
         ret = 0;
 
     ffmpeg_cleanup(ret);
+    ffmpeg_exited = 0;
 
     sch_free(&sch);
 
     av_log(NULL, AV_LOG_VERBOSE, "\n");
     av_log(NULL, AV_LOG_VERBOSE, "Exiting with exit code %d\n", ret);
 
+#ifdef __EMSCRIPTEN__
+    exit(ret);
+#endif
     return ret;
 }
Index: ffmpeg-8.0/fftools/ffprobe.c
===================================================================
--- ffmpeg-8.0.orig/fftools/ffprobe.c
+++ ffmpeg-8.0/fftools/ffprobe.c
@@ -29,6 +29,13 @@
 #include <string.h>
 #include <math.h>
 
+#if defined(__EMSCRIPTEN__) && HAVE_THREADS
+#include <emft-pthread.h>
+#define EMFT(x) emfiber_ ## x
+#else
+#define EMFT(x) x
+#endif
+
 #include "libavformat/avformat.h"
 #include "libavformat/version.h"
 #include "libavcodec/avcodec.h"
@@ -69,6 +76,8 @@
 
 #include "libavutil/thread.h"
 
+static void ffprobe_cleanup_exit(int);
+
 // attached as opaque_ref to packets/frames
 typedef struct FrameData {
     int64_t pkt_pos;
@@ -88,8 +97,10 @@ typedef struct InputFile {
     int       nb_streams;
 } InputFile;
 
+#ifndef __EMSCRIPTEN__
 const char program_name[] = "ffprobe";
 const int program_birth_year = 2007;
+#endif
 
 static int do_analyze_frames = 0;
 static int do_bitexact = 0;
@@ -2339,7 +2350,7 @@ static int open_input_file(InputFile *if
 
     ifile->streams = av_calloc(fmt_ctx->nb_streams, sizeof(*ifile->streams));
     if (!ifile->streams)
-        exit(1);
+        ffprobe_cleanup_exit(1);
     ifile->nb_streams = fmt_ctx->nb_streams;
 
     /* bind a decoder to each input stream */
@@ -2370,15 +2381,15 @@ static int open_input_file(InputFile *if
             err = filter_codec_opts(codec_opts, stream->codecpar->codec_id,
                                     fmt_ctx, stream, codec, &opts, NULL);
             if (err < 0)
-                exit(1);
+                ffprobe_cleanup_exit(1);
 
             ist->dec_ctx = avcodec_alloc_context3(codec);
             if (!ist->dec_ctx)
-                exit(1);
+                ffprobe_cleanup_exit(1);
 
             err = avcodec_parameters_to_context(ist->dec_ctx, stream->codecpar);
             if (err < 0)
-                exit(1);
+                ffprobe_cleanup_exit(1);
 
             if (do_show_log) {
                 // For logging it is needed to disable at least frame threads as otherwise
@@ -2394,7 +2405,7 @@ static int open_input_file(InputFile *if
             if (avcodec_open2(ist->dec_ctx, codec, &opts) < 0) {
                 av_log(NULL, AV_LOG_WARNING, "Could not open codec for input stream %d\n",
                        stream->index);
-                exit(1);
+                ffprobe_cleanup_exit(1);
             }
 
             if ((t = av_dict_iterate(opts, NULL))) {
@@ -2773,6 +2784,7 @@ static int opt_print_filename(void *optc
     return print_input_filename ? 0 : AVERROR(ENOMEM);
 }
 
+#ifndef __EMSCRIPTEN__
 void show_help_default(const char *opt, const char *arg)
 {
     av_log_set_callback(log_callback_help);
@@ -2783,6 +2795,7 @@ void show_help_default(const char *opt,
     show_help_children(avformat_get_class(), AV_OPT_FLAG_DECODING_PARAM);
     show_help_children(avcodec_get_class(), AV_OPT_FLAG_DECODING_PARAM);
 }
+#endif
 
 /**
  * Parse interval specification, according to the format:
@@ -3058,7 +3071,59 @@ static inline int check_section_show_ent
             do_show_##varname = 1;                                      \
     } while (0)
 
+#ifdef __EMSCRIPTEN__
+static void ffprobe_cleanup(void);
+static void ffprobe_cleanup()
+{
+    do_bitexact = do_count_frames = do_count_packets = do_read_frames =
+        do_read_packets = do_show_chapters = do_show_error = do_show_format =
+        do_show_frames = do_show_packets = do_show_programs =
+        do_show_stream_groups = do_show_stream_group_components =
+        do_show_streams = do_show_stream_disposition =
+        do_show_stream_group_disposition = do_show_data =
+        do_show_program_version = do_show_library_versions =
+        do_show_pixel_formats = 0;
+    do_show_chapter_tags = do_show_format_tags = do_show_frame_tags =
+        do_show_program_tags = do_show_stream_group_tags = do_show_stream_tags =
+        do_show_packet_tags = 0;
+    show_value_unit = use_value_prefix = use_byte_value_binary_prefix =
+        use_value_sexagesimal_format = 0;
+    show_private_data = 1;
+    show_optional_fields = SHOW_OPTIONAL_FIELDS_AUTO;
+
+    av_freep(&output_format);
+    av_freep(&stream_specifier);
+    av_freep(&show_data_hash);
+
+    av_freep(&read_intervals);
+    read_intervals_nb = 0;
+
+    find_stream_info = 1;
+
+    options = NULL;
+
+    av_freep(&input_filename);
+    av_freep(&print_input_filename);
+    iformat = NULL;
+    av_freep(&output_filename);
+
+    nb_streams = 0;
+    av_freep(&nb_streams_packets);
+    av_freep(&nb_streams_frames);
+    av_freep(&selected_streams);
+}
+
+static void ffprobe_cleanup_exit(int code)
+{
+    ffprobe_cleanup();
+    exit(code);
+}
+
+int ffprobe_main(int argc, char **argv);
+int ffprobe_main(int argc, char **argv)
+#else
 int main(int argc, char **argv)
+#endif
 {
     const AVTextFormatter *f;
     AVTextFormatContext *tctx;
Index: ffmpeg-8.0/fftools/ffmpeg_sched.c
===================================================================
--- ffmpeg-8.0.orig/fftools/ffmpeg_sched.c
+++ ffmpeg-8.0/fftools/ffmpeg_sched.c
@@ -50,8 +50,8 @@ enum QueueType {
 };
 
 typedef struct SchWaiter {
-    pthread_mutex_t     lock;
-    pthread_cond_t      cond;
+    EMFT(pthread_mutex_t)     lock;
+    EMFT(pthread_cond_t)      cond;
     atomic_int          choked;
 
     // the following are internal state of schedule_update_locked() and must not
@@ -67,7 +67,7 @@ typedef struct SchTask {
     SchThreadFunc       func;
     void               *func_arg;
 
-    pthread_t           thread;
+    EMFT(pthread_t)           thread;
     int                 thread_running;
 } SchTask;
 
@@ -100,7 +100,7 @@ typedef struct SchDec {
 typedef struct SchSyncQueue {
     SyncQueue          *sq;
     AVFrame            *frame;
-    pthread_mutex_t     lock;
+    EMFT(pthread_mutex_t)     lock;
 
     unsigned           *enc_idx;
     unsigned         nb_enc_idx;
@@ -282,12 +282,12 @@ struct Scheduler {
     unsigned         nb_mux;
 
     unsigned         nb_mux_ready;
-    pthread_mutex_t     mux_ready_lock;
+    EMFT(pthread_mutex_t)     mux_ready_lock;
 
     unsigned         nb_mux_done;
     unsigned            task_failed;
-    pthread_mutex_t     finish_lock;
-    pthread_cond_t      finish_cond;
+    EMFT(pthread_mutex_t)     finish_lock;
+    EMFT(pthread_cond_t)      finish_cond;
 
 
     SchDec             *dec;
@@ -308,7 +308,7 @@ struct Scheduler {
     enum SchedulerState state;
     atomic_int          terminate;
 
-    pthread_mutex_t     schedule_lock;
+    EMFT(pthread_mutex_t)     schedule_lock;
 
     atomic_int_least64_t last_dts;
 };
@@ -326,26 +326,26 @@ static int waiter_wait(Scheduler *sch, S
     if (!atomic_load(&w->choked))
         return 0;
 
-    pthread_mutex_lock(&w->lock);
+    EMFT(pthread_mutex_lock)(&w->lock);
 
     while (atomic_load(&w->choked) && !atomic_load(&sch->terminate))
-        pthread_cond_wait(&w->cond, &w->lock);
+        EMFT(pthread_cond_wait)(&w->cond, &w->lock);
 
     terminate = atomic_load(&sch->terminate);
 
-    pthread_mutex_unlock(&w->lock);
+    EMFT(pthread_mutex_unlock)(&w->lock);
 
     return terminate;
 }
 
 static void waiter_set(SchWaiter *w, int choked)
 {
-    pthread_mutex_lock(&w->lock);
+    EMFT(pthread_mutex_lock)(&w->lock);
 
     atomic_store(&w->choked, choked);
-    pthread_cond_signal(&w->cond);
+    EMFT(pthread_cond_signal)(&w->cond);
 
-    pthread_mutex_unlock(&w->lock);
+    EMFT(pthread_mutex_unlock)(&w->lock);
 }
 
 static int waiter_init(SchWaiter *w)
@@ -354,11 +354,11 @@ static int waiter_init(SchWaiter *w)
 
     atomic_init(&w->choked, 0);
 
-    ret = pthread_mutex_init(&w->lock, NULL);
+    ret = EMFT(pthread_mutex_init)(&w->lock, NULL);
     if (ret)
         return AVERROR(ret);
 
-    ret = pthread_cond_init(&w->cond, NULL);
+    ret = EMFT(pthread_cond_init)(&w->cond, NULL);
     if (ret)
         return AVERROR(ret);
 
@@ -367,8 +367,8 @@ static int waiter_init(SchWaiter *w)
 
 static void waiter_uninit(SchWaiter *w)
 {
-    pthread_mutex_destroy(&w->lock);
-    pthread_cond_destroy(&w->cond);
+    EMFT(pthread_mutex_destroy)(&w->lock);
+    EMFT(pthread_cond_destroy)(&w->cond);
 }
 
 static int queue_alloc(ThreadQueue **ptq, unsigned nb_streams, unsigned queue_size,
@@ -411,7 +411,7 @@ static int task_start(SchTask *task)
 
     av_assert0(!task->thread_running);
 
-    ret = pthread_create(&task->thread, NULL, task_wrapper, task);
+    ret = EMFT(pthread_create)(&task->thread, NULL, task_wrapper, task);
     if (ret) {
         av_log(task->func_arg, AV_LOG_ERROR, "pthread_create() failed: %s\n",
                strerror(ret));
@@ -540,7 +540,7 @@ void sch_free(Scheduler **psch)
         SchSyncQueue *sq = &sch->sq_enc[i];
         sq_free(&sq->sq);
         av_frame_free(&sq->frame);
-        pthread_mutex_destroy(&sq->lock);
+        EMFT(pthread_mutex_destroy)(&sq->lock);
         av_freep(&sq->enc_idx);
     }
     av_freep(&sch->sq_enc);
@@ -559,12 +559,12 @@ void sch_free(Scheduler **psch)
 
     av_freep(&sch->sdp_filename);
 
-    pthread_mutex_destroy(&sch->schedule_lock);
+    EMFT(pthread_mutex_destroy)(&sch->schedule_lock);
 
-    pthread_mutex_destroy(&sch->mux_ready_lock);
+    EMFT(pthread_mutex_destroy)(&sch->mux_ready_lock);
 
-    pthread_mutex_destroy(&sch->finish_lock);
-    pthread_cond_destroy(&sch->finish_cond);
+    EMFT(pthread_mutex_destroy)(&sch->finish_lock);
+    EMFT(pthread_cond_destroy)(&sch->finish_cond);
 
     av_freep(psch);
 }
@@ -586,19 +586,19 @@ Scheduler *sch_alloc(void)
     sch->class    = &scheduler_class;
     sch->sdp_auto = 1;
 
-    ret = pthread_mutex_init(&sch->schedule_lock, NULL);
+    ret = EMFT(pthread_mutex_init)(&sch->schedule_lock, NULL);
     if (ret)
         goto fail;
 
-    ret = pthread_mutex_init(&sch->mux_ready_lock, NULL);
+    ret = EMFT(pthread_mutex_init)(&sch->mux_ready_lock, NULL);
     if (ret)
         goto fail;
 
-    ret = pthread_mutex_init(&sch->finish_lock, NULL);
+    ret = EMFT(pthread_mutex_init)(&sch->finish_lock, NULL);
     if (ret)
         goto fail;
 
-    ret = pthread_cond_init(&sch->finish_cond, NULL);
+    ret = EMFT(pthread_cond_init)(&sch->finish_cond, NULL);
     if (ret)
         goto fail;
 
@@ -878,7 +878,7 @@ int sch_add_sq_enc(Scheduler *sch, uint6
     if (!sq->frame)
         return AVERROR(ENOMEM);
 
-    ret = pthread_mutex_init(&sq->lock, NULL);
+    ret = EMFT(pthread_mutex_init)(&sq->lock, NULL);
     if (ret)
         return AVERROR(ret);
 
@@ -1220,7 +1220,7 @@ int sch_mux_stream_ready(Scheduler *sch,
 
     av_assert0(stream_idx < mux->nb_streams);
 
-    pthread_mutex_lock(&sch->mux_ready_lock);
+    EMFT(pthread_mutex_lock)(&sch->mux_ready_lock);
 
     av_assert0(mux->nb_streams_ready < mux->nb_streams);
 
@@ -1230,7 +1230,7 @@ int sch_mux_stream_ready(Scheduler *sch,
         sch->state >= SCH_STATE_STARTED)
         ret = mux_init(sch, mux);
 
-    pthread_mutex_unlock(&sch->mux_ready_lock);
+    EMFT(pthread_mutex_unlock)(&sch->mux_ready_lock);
 
     return ret;
 }
@@ -1644,9 +1644,9 @@ int sch_start(Scheduler *sch)
             goto fail;
     }
 
-    pthread_mutex_lock(&sch->schedule_lock);
+    EMFT(pthread_mutex_lock)(&sch->schedule_lock);
     schedule_update_locked(sch);
-    pthread_mutex_unlock(&sch->schedule_lock);
+    EMFT(pthread_mutex_unlock)(&sch->schedule_lock);
 
     return 0;
 fail:
@@ -1661,18 +1661,18 @@ int sch_wait(Scheduler *sch, uint64_t ti
     // convert delay to absolute timestamp
     timeout_us += av_gettime();
 
-    pthread_mutex_lock(&sch->finish_lock);
+    EMFT(pthread_mutex_lock)(&sch->finish_lock);
 
     if (sch->nb_mux_done < sch->nb_mux) {
         struct timespec tv = { .tv_sec  =  timeout_us / 1000000,
                                .tv_nsec = (timeout_us % 1000000) * 1000 };
-        pthread_cond_timedwait(&sch->finish_cond, &sch->finish_lock, &tv);
+        EMFT(pthread_cond_timedwait)(&sch->finish_cond, &sch->finish_lock, &tv);
     }
 
     // abort transcoding if any task failed
     ret = sch->nb_mux_done == sch->nb_mux || sch->task_failed;
 
-    pthread_mutex_unlock(&sch->finish_lock);
+    EMFT(pthread_mutex_unlock)(&sch->finish_lock);
 
     *transcode_ts = atomic_load(&sch->last_dts);
 
@@ -1695,11 +1695,11 @@ static int enc_open(Scheduler *sch, SchE
         av_assert0(enc->sq_idx[0] >= 0);
         sq = &sch->sq_enc[enc->sq_idx[0]];
 
-        pthread_mutex_lock(&sq->lock);
+        EMFT(pthread_mutex_lock)(&sq->lock);
 
         sq_frame_samples(sq->sq, enc->sq_idx[1], ret);
 
-        pthread_mutex_unlock(&sq->lock);
+        EMFT(pthread_mutex_unlock)(&sq->lock);
     }
 
     return 0;
@@ -1745,16 +1745,16 @@ static int send_to_enc_sq(Scheduler *sch
             mux = &sch->mux[enc->dst[i].idx];
             ms = &mux->streams[enc->dst[i].idx_stream];
 
-            pthread_mutex_lock(&sch->schedule_lock);
+            EMFT(pthread_mutex_lock)(&sch->schedule_lock);
 
             ms->source_finished = 1;
             schedule_update_locked(sch);
 
-            pthread_mutex_unlock(&sch->schedule_lock);
+            EMFT(pthread_mutex_unlock)(&sch->schedule_lock);
         }
     }
 
-    pthread_mutex_lock(&sq->lock);
+    EMFT(pthread_mutex_lock)(&sq->lock);
 
     ret = sq_send(sq->sq, enc->sq_idx[1], SQFRAME(frame));
     if (ret < 0)
@@ -1795,7 +1795,7 @@ static int send_to_enc_sq(Scheduler *sch
     }
 
 finish:
-    pthread_mutex_unlock(&sq->lock);
+    EMFT(pthread_mutex_unlock)(&sq->lock);
 
     return ret;
 }
@@ -1870,14 +1870,14 @@ static int send_to_mux(Scheduler *sch, S
 
         // the muxer could have started between the above atomic check and
         // locking the mutex, then this block falls through to normal send path
-        pthread_mutex_lock(&sch->mux_ready_lock);
+        EMFT(pthread_mutex_lock)(&sch->mux_ready_lock);
 
         if (!atomic_load(&mux->mux_started)) {
             int ret = mux_queue_packet(mux, ms, pkt);
             queued = ret < 0 ? ret : 1;
         }
 
-        pthread_mutex_unlock(&sch->mux_ready_lock);
+        EMFT(pthread_mutex_unlock)(&sch->mux_ready_lock);
 
         if (queued < 0)
             return queued;
@@ -1901,14 +1901,14 @@ update_schedule:
     // TODO: use atomics to check whether this changes trailing dts
     // to avoid locking unnecessarily
     if (dts != AV_NOPTS_VALUE || !pkt) {
-        pthread_mutex_lock(&sch->schedule_lock);
+        EMFT(pthread_mutex_lock)(&sch->schedule_lock);
 
         if (pkt) ms->last_dts = dts;
         else     ms->source_finished = 1;
 
         schedule_update_locked(sch);
 
-        pthread_mutex_unlock(&sch->schedule_lock);
+        EMFT(pthread_mutex_unlock)(&sch->schedule_lock);
     }
 
     return 0;
@@ -2059,13 +2059,13 @@ static int demux_done(Scheduler *sch, un
             ret = err_merge(ret, err);
     }
 
-    pthread_mutex_lock(&sch->schedule_lock);
+    EMFT(pthread_mutex_lock)(&sch->schedule_lock);
 
     d->task_exited = 1;
 
     schedule_update_locked(sch);
 
-    pthread_mutex_unlock(&sch->schedule_lock);
+    EMFT(pthread_mutex_unlock)(&sch->schedule_lock);
 
     return ret;
 }
@@ -2093,12 +2093,12 @@ void sch_mux_receive_finish(Scheduler *s
     av_assert0(stream_idx < mux->nb_streams);
     tq_receive_finish(mux->queue, stream_idx);
 
-    pthread_mutex_lock(&sch->schedule_lock);
+    EMFT(pthread_mutex_lock)(&sch->schedule_lock);
     mux->streams[stream_idx].source_finished = 1;
 
     schedule_update_locked(sch);
 
-    pthread_mutex_unlock(&sch->schedule_lock);
+    EMFT(pthread_mutex_unlock)(&sch->schedule_lock);
 }
 
 int sch_mux_sub_heartbeat(Scheduler *sch, unsigned mux_idx, unsigned stream_idx,
@@ -2131,7 +2131,7 @@ static int mux_done(Scheduler *sch, unsi
 {
     SchMux *mux = &sch->mux[mux_idx];
 
-    pthread_mutex_lock(&sch->schedule_lock);
+    EMFT(pthread_mutex_lock)(&sch->schedule_lock);
 
     for (unsigned i = 0; i < mux->nb_streams; i++) {
         tq_receive_finish(mux->queue, i);
@@ -2140,16 +2140,16 @@ static int mux_done(Scheduler *sch, unsi
 
     schedule_update_locked(sch);
 
-    pthread_mutex_unlock(&sch->schedule_lock);
+    EMFT(pthread_mutex_unlock)(&sch->schedule_lock);
 
-    pthread_mutex_lock(&sch->finish_lock);
+    EMFT(pthread_mutex_lock)(&sch->finish_lock);
 
     av_assert0(sch->nb_mux_done < sch->nb_mux);
     sch->nb_mux_done++;
 
-    pthread_cond_signal(&sch->finish_cond);
+    EMFT(pthread_cond_signal)(&sch->finish_cond);
 
-    pthread_mutex_unlock(&sch->finish_lock);
+    EMFT(pthread_mutex_unlock)(&sch->finish_lock);
 
     return 0;
 }
@@ -2407,12 +2407,12 @@ int sch_filter_receive(Scheduler *sch, u
     // this check needs no locking because only the filtering thread
     // updates this value
     if (*in_idx != fg->best_input) {
-        pthread_mutex_lock(&sch->schedule_lock);
+        EMFT(pthread_mutex_lock)(&sch->schedule_lock);
 
         fg->best_input = *in_idx;
         schedule_update_locked(sch);
 
-        pthread_mutex_unlock(&sch->schedule_lock);
+        EMFT(pthread_mutex_unlock)(&sch->schedule_lock);
     }
 
     if (*in_idx == fg->nb_inputs) {
@@ -2491,13 +2491,13 @@ static int filter_done(Scheduler *sch, u
             ret = err_merge(ret, err);
     }
 
-    pthread_mutex_lock(&sch->schedule_lock);
+    EMFT(pthread_mutex_lock)(&sch->schedule_lock);
 
     fg->task_exited = 1;
 
     schedule_update_locked(sch);
 
-    pthread_mutex_unlock(&sch->schedule_lock);
+    EMFT(pthread_mutex_unlock)(&sch->schedule_lock);
 
     return ret;
 }
@@ -2543,10 +2543,10 @@ static void *task_wrapper(void *arg)
     if (ret == AVERROR_EOF)
         ret = 0;
     if (ret < 0) {
-        pthread_mutex_lock(&sch->finish_lock);
+        EMFT(pthread_mutex_lock)(&sch->finish_lock);
         sch->task_failed = 1;
-        pthread_cond_signal(&sch->finish_cond);
-        pthread_mutex_unlock(&sch->finish_lock);
+        EMFT(pthread_cond_signal)(&sch->finish_cond);
+        EMFT(pthread_mutex_unlock)(&sch->finish_lock);
     }
 
     av_log(task->func_arg, ret < 0 ? AV_LOG_ERROR : AV_LOG_VERBOSE,
@@ -2564,7 +2564,7 @@ static int task_stop(Scheduler *sch, Sch
     if (!task->thread_running)
         return task_cleanup(sch, task->node);
 
-    ret = pthread_join(task->thread, &thread_ret);
+    ret = EMFT(pthread_join)(task->thread, &thread_ret);
     av_assert0(ret == 0);
 
     task->thread_running = 0;
Index: ffmpeg-8.0/fftools/thread_queue.c
===================================================================
--- ffmpeg-8.0.orig/fftools/thread_queue.c
+++ ffmpeg-8.0/fftools/thread_queue.c
@@ -19,6 +19,13 @@
 #include <stdint.h>
 #include <string.h>
 
+#ifdef __EMSCRIPTEN__
+#include <emft-pthread.h>
+#define EMFT(x) emfiber_ ## x
+#else
+#define EMFT(x) x
+#endif
+
 #include "libavutil/avassert.h"
 #include "libavutil/container_fifo.h"
 #include "libavutil/error.h"
@@ -46,8 +53,8 @@ struct ThreadQueue {
     AVContainerFifo *fifo;
     AVFifo          *fifo_stream_index;
 
-    pthread_mutex_t lock;
-    pthread_cond_t  cond;
+    EMFT(pthread_mutex_t) lock;
+    EMFT(pthread_cond_t)  cond;
 };
 
 void tq_free(ThreadQueue **ptq)
@@ -62,8 +69,8 @@ void tq_free(ThreadQueue **ptq)
 
     av_freep(&tq->finished);
 
-    pthread_cond_destroy(&tq->cond);
-    pthread_mutex_destroy(&tq->lock);
+    EMFT(pthread_cond_destroy)(&tq->cond);
+    EMFT(pthread_mutex_destroy)(&tq->lock);
 
     av_freep(ptq);
 }
@@ -78,15 +85,15 @@ ThreadQueue *tq_alloc(unsigned int nb_st
     if (!tq)
         return NULL;
 
-    ret = pthread_cond_init(&tq->cond, NULL);
+    ret = EMFT(pthread_cond_init)(&tq->cond, NULL);
     if (ret) {
         av_freep(&tq);
         return NULL;
     }
 
-    ret = pthread_mutex_init(&tq->lock, NULL);
+    ret = EMFT(pthread_mutex_init)(&tq->lock, NULL);
     if (ret) {
-        pthread_cond_destroy(&tq->cond);
+        EMFT(pthread_cond_destroy)(&tq->cond);
         av_freep(&tq);
         return NULL;
     }
@@ -121,7 +128,7 @@ int tq_send(ThreadQueue *tq, unsigned in
     av_assert0(stream_idx < tq->nb_streams);
     finished = &tq->finished[stream_idx];
 
-    pthread_mutex_lock(&tq->lock);
+    EMFT(pthread_mutex_lock)(&tq->lock);
 
     if (*finished & FINISHED_SEND) {
         ret = AVERROR(EINVAL);
@@ -129,7 +136,7 @@ int tq_send(ThreadQueue *tq, unsigned in
     }
 
     while (!(*finished & FINISHED_RECV) && !av_fifo_can_write(tq->fifo_stream_index))
-        pthread_cond_wait(&tq->cond, &tq->lock);
+        EMFT(pthread_cond_wait)(&tq->cond, &tq->lock);
 
     if (*finished & FINISHED_RECV) {
         ret = AVERROR_EOF;
@@ -143,11 +150,11 @@ int tq_send(ThreadQueue *tq, unsigned in
         if (ret < 0)
             goto finish;
 
-        pthread_cond_broadcast(&tq->cond);
+        EMFT(pthread_cond_broadcast)(&tq->cond);
     }
 
 finish:
-    pthread_mutex_unlock(&tq->lock);
+    EMFT(pthread_mutex_unlock)(&tq->lock);
 
     return ret;
 }
@@ -196,7 +203,7 @@ int tq_receive(ThreadQueue *tq, int *str
 
     *stream_idx = -1;
 
-    pthread_mutex_lock(&tq->lock);
+    EMFT(pthread_mutex_lock)(&tq->lock);
 
     while (1) {
         size_t can_read = av_container_fifo_can_read(tq->fifo);
@@ -205,17 +212,17 @@ int tq_receive(ThreadQueue *tq, int *str
 
         // signal other threads if the fifo state changed
         if (can_read != av_container_fifo_can_read(tq->fifo))
-            pthread_cond_broadcast(&tq->cond);
+            EMFT(pthread_cond_broadcast)(&tq->cond);
 
         if (ret == AVERROR(EAGAIN)) {
-            pthread_cond_wait(&tq->cond, &tq->lock);
+            EMFT(pthread_cond_wait)(&tq->cond, &tq->lock);
             continue;
         }
 
         break;
     }
 
-    pthread_mutex_unlock(&tq->lock);
+    EMFT(pthread_mutex_unlock)(&tq->lock);
 
     return ret;
 }
@@ -224,28 +231,28 @@ void tq_send_finish(ThreadQueue *tq, uns
 {
     av_assert0(stream_idx < tq->nb_streams);
 
-    pthread_mutex_lock(&tq->lock);
+    EMFT(pthread_mutex_lock)(&tq->lock);
 
     /* mark the stream as send-finished;
      * next time the consumer thread tries to read this stream it will get
      * an EOF and recv-finished flag will be set */
     tq->finished[stream_idx] |= FINISHED_SEND;
-    pthread_cond_broadcast(&tq->cond);
+    EMFT(pthread_cond_broadcast)(&tq->cond);
 
-    pthread_mutex_unlock(&tq->lock);
+    EMFT(pthread_mutex_unlock)(&tq->lock);
 }
 
 void tq_receive_finish(ThreadQueue *tq, unsigned int stream_idx)
 {
     av_assert0(stream_idx < tq->nb_streams);
 
-    pthread_mutex_lock(&tq->lock);
+    EMFT(pthread_mutex_lock)(&tq->lock);
 
     /* mark the stream as recv-finished;
      * next time the producer thread tries to send for this stream, it will
      * get an EOF and send-finished flag will be set */
     tq->finished[stream_idx] |= FINISHED_RECV;
-    pthread_cond_broadcast(&tq->cond);
+    EMFT(pthread_cond_broadcast)(&tq->cond);
 
-    pthread_mutex_unlock(&tq->lock);
+    EMFT(pthread_mutex_unlock)(&tq->lock);
 }
Index: ffmpeg-8.0/fftools/ffmpeg.h
===================================================================
--- ffmpeg-8.0.orig/fftools/ffmpeg.h
+++ ffmpeg-8.0/fftools/ffmpeg.h
@@ -559,7 +559,7 @@ typedef struct EncStats {
 
     AVIOContext        *io;
 
-    pthread_mutex_t     lock;
+    EMFT(pthread_mutex_t)     lock;
     int                 lock_initialized;
 } EncStats;
 
Index: ffmpeg-8.0/fftools/ffmpeg_enc.c
===================================================================
--- ffmpeg-8.0.orig/fftools/ffmpeg_enc.c
+++ ffmpeg-8.0/fftools/ffmpeg_enc.c
@@ -478,7 +478,7 @@ void enc_stats_write(OutputStream *ost,
         ptsi = fd->dec.pts;
     }
 
-    pthread_mutex_lock(&es->lock);
+    EMFT(pthread_mutex_lock)(&es->lock);
 
     for (size_t i = 0; i < es->nb_components; i++) {
         const EncStatsComponent *c = &es->components[i];
@@ -528,7 +528,7 @@ void enc_stats_write(OutputStream *ost,
     avio_w8(io, '\n');
     avio_flush(io);
 
-    pthread_mutex_unlock(&es->lock);
+    EMFT(pthread_mutex_unlock)(&es->lock);
 }
 
 static inline double psnr(double d)
Index: ffmpeg-8.0/fftools/ffmpeg_mux.c
===================================================================
--- ffmpeg-8.0.orig/fftools/ffmpeg_mux.c
+++ ffmpeg-8.0/fftools/ffmpeg_mux.c
@@ -799,7 +799,7 @@ static void enc_stats_uninit(EncStats *e
     av_freep(&es->components);
 
     if (es->lock_initialized)
-        pthread_mutex_destroy(&es->lock);
+        EMFT(pthread_mutex_destroy)(&es->lock);
     es->lock_initialized = 0;
 }
 
Index: ffmpeg-8.0/fftools/ffmpeg_mux_init.c
===================================================================
--- ffmpeg-8.0.orig/fftools/ffmpeg_mux_init.c
+++ ffmpeg-8.0/fftools/ffmpeg_mux_init.c
@@ -363,7 +363,7 @@ fail:
             return ret;
     }
 
-    ret = pthread_mutex_init(&es->lock, NULL);
+    ret = EMFT(pthread_mutex_init)(&es->lock, NULL);
     if (ret)
         return AVERROR(ret);
     es->lock_initialized = 1;
Index: ffmpeg-8.0/fftools/ffmpeg_sched.h
===================================================================
--- ffmpeg-8.0.orig/fftools/ffmpeg_sched.h
+++ ffmpeg-8.0/fftools/ffmpeg_sched.h
@@ -25,6 +25,13 @@
 #include <stddef.h>
 #include <stdint.h>
 
+#ifdef __EMSCRIPTEN__
+#include <emft-pthread.h>
+#define EMFT(x) emfiber_ ## x
+#else
+#define EMFT(x) x
+#endif
+
 #include "ffmpeg_utils.h"
 
 /*
